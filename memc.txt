#include <memory.h>

extern uint32_t g_pageDirectory[];
extern uint32_t g_pageTableArray[];
extern uint32_t e_frameBitsetVirt[];
extern uint32_t e_frameBitsetSize;
extern uint32_t e_placement;

// Can allocate up to 256 MB of RAM.  No need for more I think,
// but if there is a need, just increase this.
PageTable g_pageTableThing[65536]; 

//uses global page directory.
PageTable* KeGetPage(uint32_t address, bool make)
{
	address /= 0x1000;
	
	uint32_t tableIndex = address / 1024, entryIndex = address % 1024;
	
	if (g_pageDirectory[tableIndex])
	{
		return (PageTable*)(BASE_ADDRESS + (g_pageDirectory[tableIndex] & ~0xFFF));
	}
	else if (make)
	{
		
	}
	else
		return NULL;
}

uint32_t g_memoryStart;

void KeInitPaging()
{
	e_placement += 0x1000;
	e_placement &= ~0xFFF;
	
	g_memoryStart = e_placement;
}

#define  INDEX_FROM_BIT(a) (a / 32)
#define OFFSET_FROM_BIT(a) (a % 32)

static void SetFrame (uint32_t frameAddr)
{
	uint32_t frame = frameAddr / 0x1000;
	uint32_t idx = INDEX_FROM_BIT (frame),
			 off =OFFSET_FROM_BIT (frame);
	e_frameBitsetVirt[idx] |= (0x1 << off);
}
static void ClrFrame (uint32_t frameAddr)
{
	uint32_t frame = frameAddr / 0x1000;
	uint32_t idx = INDEX_FROM_BIT (frame),
			 off =OFFSET_FROM_BIT (frame);
	e_frameBitsetVirt[idx] &=~(0x1 << off);
}
static bool TestFrame(uint32_t frameAddr) 
{
	uint32_t frame = frameAddr / 0x1000;
	uint32_t idx = INDEX_FROM_BIT (frame),
			 off =OFFSET_FROM_BIT (frame);
	return (e_frameBitsetVirt[idx] & (1 << off)) != 0;
}
static uint32_t FindFreeFrame()
{
	for (uint32_t i=0; i<INDEX_FROM_BIT(e_frameBitsetSize); i++)
	{
		//Any bit free?
		if (e_frameBitsetVirt[i] != 0xFFFFFFFF) {
			//yes, which?
			for (int j=0; j<32; j++)
			{
				if (!(e_frameBitsetVirt[i] & (1<<j)))
					return i*32 + j;
			}
		}
		//no, continue
	}
	//what
	return 0xffffffffu/*ck you*/;
}

// Allocates a page frame.
void KeAllocFrame (PageEntry *pPage, bool bUserSuper, bool bWritable)
{
	if (pPage->m_pAddress != 0) return;
	
	uint32_t index = FindFreeFrame();
	
	//ASSERT(index == 0xffffffffu/*ck you*/ && "No free frames!?");
	
	SetFrame (index * 0x1000);
	pPage->m_bPresent = 1;
	pPage->m_bReadWrite = bWritable;
	pPage->m_bUserSuper = bUserSuper;
	pPage->m_pAddress = index;
}

// Deallocate a page frame
void KeFreeFrame (PageEntry* pPage)
{
	uint32_t frame;
	if (!(frame = pPage->m_pAddress)) return;
	
	ClrFrame(frame);
	pPage->m_pAddress = 0;
}

uint32_t* e_frameBitsetVirt = NULL, e_frameBitsetSize = 0;

// We start allocations at 0x100000, and end at 0x80000000
typedef struct AllocatedMemory
{
    void* start; size_t size;
    const char* callerFile; int callerLine;
} 
AllocatedMemory;
typedef struct FreeMemory
{
    void* start; size_t size;
} FreeMemory;

AllocatedMemory g_blocks    [BLOCK_COUNT];
FreeMemory      g_freeBlocks[BLOCK_COUNT];

void PrintMemoryDebug()
{
    LogMsg("Allocations:");
    int i = 0;
    for (; i < BLOCK_COUNT; i++)
    {
        if (g_blocks[i].start == (void*)0xFFFFFFFF || g_blocks[i].start == NULL) break;
        LogMsg("[A]: start: 0x%x, size: 0x%x %d, calledby: %s:%d", (int)g_blocks[i].start, g_blocks[i].size, g_blocks[i].size, g_blocks[i].callerFile, g_blocks[i].callerLine);
    }
    if (i == 0) LogMsg("None.");
    i = 0;
    LogMsg("Free slots:");
    for (; i < BLOCK_COUNT; i++)
    {
        if (g_freeBlocks[i].start == (void*)0xFFFFFFFF || g_freeBlocks[i].start == NULL) break;
        LogMsg("[F]: start: 0x%x, size: 0x%x %d", (int)g_freeBlocks[i].start, g_freeBlocks[i].size, g_freeBlocks[i].size);
    }
    if (i == 0) LogMsg("None???");
    LogMsg("\n");
}

#define mm_min(a,b)((a)<(b)?(a):(b))
#define mm_max(a,b)((a)>(b)?(a):(b))

void ConnectNeighboringOrOverlappingFreeMemRegions()
{
    for (int i = 0; i < BLOCK_COUNT; i++)
    {
        if (g_freeBlocks[i].start == (void*)0xFFFFFFFF) break;
        for (int j = 0; j < BLOCK_COUNT; j++)
        {
            if (g_freeBlocks[j].start == (void*)0xFFFFFFFF) break;
            if (i == j) continue;
            void* start1 = g_freeBlocks[i].start;
            void* start2 = g_freeBlocks[j].start;
            void* end1 = (uint8_t*)start1 + g_freeBlocks[i].size;
            void* end2 = (uint8_t*)start2 + g_freeBlocks[j].size;

            //do these regions overlap in anyway?
            if ((uintptr_t)start1 <= (uintptr_t)end2 && (uintptr_t)start2 <= (uintptr_t)end1)
            {
                uint8_t* minStart, * maxEnd;
                minStart = (uint8_t*)mm_min((int)start1, (int)start2);
                maxEnd   = (uint8_t*)mm_max((int)end1,   (int)end2);
                g_freeBlocks[i].start = minStart;
                g_freeBlocks[i].size  = maxEnd - minStart;
                g_freeBlocks[j].start = NULL;
                g_freeBlocks[j].size = 0;
            }
        }
    }
}
void KeAddFreeMemoryRange(void* start, size_t size)
{
    //find free slot
    int freeSlot = -1;
    for (int i = 0; i < BLOCK_COUNT; i++)
    {
        if (g_freeBlocks[i].start == 0 || g_freeBlocks[i].start == (void*)0xFFFFFFFF)
        {
            freeSlot = i; break;
        }
    }
    //set the free memory block
    if (freeSlot == -1)
    {
        LogMsg("[!!! FATAL ERROR !!!] %s:%d KeAddFreeMemoryRange failed. Start: 0x%x, size: 0x%x %d", __FILE__, __LINE__, (int)start, size, size);
        return;
    }
    
    g_freeBlocks[freeSlot].start = start;
    g_freeBlocks[freeSlot].size  = size;

    ConnectNeighboringOrOverlappingFreeMemRegions();
}
void* KeRequestRangeToMap(int size, const char* calledBy, int callLine, uint32_t* pSizeOut)
{
	//When we request a non-4096-aligned size, align it to 4096
	if (size & 0xFFF) {
		size += 0x1000;
		size &= ~0xFFF;
	}
    int freeSlot = -1;
    for (int i = 0; i < BLOCK_COUNT; i++)
    {
        if (g_blocks[i].start == NULL || g_blocks[i].start == (void*)0xFFFFFFFF)
        {
            freeSlot = i; break;
        }
    }
    //set the free memory block
    if (freeSlot == -1)
    {
        LogMsg("[!!! FATAL ERROR !!!] %s:%d KeRequestRangeToMap failed (no more memory ranges left in the free pool). Size: 0x%x %d, called by %s:%d", __FILE__, __LINE__, size, size, calledBy, callLine);
        return NULL;
    }

    //look through all the free blocks
    int freeBlock = -1;
    for (int i = 0; i < BLOCK_COUNT; i++)
    {
        if (g_freeBlocks[i].start != NULL && g_freeBlocks[i].start != (void*)0xFFFFFFFF)
        {
            //check if we can fit here
            if (g_freeBlocks[i].size >= size)
            {
                freeBlock = i;
                break;
            }
        }
    }
    if (freeBlock == -1)
    {
        LogMsg("[!!! FATAL ERROR !!!] %s:%d KeRequestRangeToMap failed (no memory ranges that can fit this much data). Size: 0x%x %d, called by %s:%d", __FILE__, __LINE__, size, size, calledBy, callLine);
        return NULL;
    }

    //do math
    FreeMemory* p = &g_freeBlocks[freeBlock];//p because I don't like typing that long thing again
    void* newMemory = p->start;
    p->start = (void*)((uint8_t*)p->start + size);
    p->size -= size;
    if (p->size == 0) p->start = NULL;

    AllocatedMemory* pMem = &g_blocks[freeSlot];
    pMem->start = newMemory;
    pMem->size  = size;
	if (pSizeOut)
		*pSizeOut = size;
    pMem->callerFile = calledBy;
    pMem->callerLine = callLine;

    return newMemory;
}
void KeMarkMemoryRangeFree(void* mem, const char* pCalledBy, int calledLine)
{
    //find it in the allocations list
    for (int i = 0; i < BLOCK_COUNT; i++)
    {
        if (g_blocks[i].start == (void*)0xFFFFFFFF) break;
        if (g_blocks[i].start == mem)
        {
            //add to free list
            AddFreeMemoryBlock(g_blocks[i].start, g_blocks[i].size);
            //memset to zero, for security
            memset(g_blocks[i].start, 0, g_blocks[i].size);
            //reset the block data
            g_blocks[i].start = NULL;
            g_blocks[i].size  = 0;
            g_blocks[i].callerFile = NULL;
            g_blocks[i].callerLine = 0;
            return;
        }
    }
    LogMsg("Attempted to free something not in the heap, address: 0x%x. Called by %s:%d", (int)mem, pCalledBy, calledLine);
}
bool g_heapInitialized = false;
void KeInitializeHeap()
{
	g_heapInitialized = true;
    for (int i = 0; i < BLOCK_COUNT; i++)
    {
        //set to uninitialized.
        //this is different from just 0x00'ing, because it means we can end right here and there's no more blocks to count.
        g_blocks[i].start     = (void*)0xFFFFFFFF;
        g_blocks[i].size      =        0x00000000;
        g_freeBlocks[i].start = (void*)0xFFFFFFFF;
        g_freeBlocks[i].size  =        0x00000000;
    }
    KeAddFreeMemoryRange(0x100000, e_frameBitsetSize * 8 * 4096);
}

void* KeAllocateMemory(size_t size, const char* pCalledBy, int calledByLine)
{
	// First of all, we will reserve the address range we want to map
	
	uint32_t sizeInternal = 0xDEADDEAD; // If allocation failed, size will be equal to a non-4096-aligned value.
	void* pMemoryRange = KeRequestRangeToMap (size, pCalledBy, calledByLine, &sizeInternal);
	if (sizeInternal == 0xDEADDEAD || !pMemoryRange)
		return NULL;
	
	// Once we got the memory range, let's actually map it. 
	uint32_t addr = (uint32_t)pMemoryRange;
	while (sizeInternal)
	{
		int pdIndex = (addr >> 22);
		int ptIndex = (addr >> 12) & 0x3FF;
		
		//PageEntry *pEntry = KeG
		
		sizeInternal -= 4096;
	}
}




